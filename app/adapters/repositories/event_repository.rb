# frozen_string_literal: true

require_relative "../../ports/storage_port"
require_relative "../../core/domain/event_factory"

module Repositories
  # Database implementation of event storage using DomainEvent model
  class EventRepository
    include StoragePort

    require "securerandom"

    def initialize(logger_port: nil)
      # Use memory as a cache, not primary storage
      @events_cache = {}
      @logger_port = logger_port || Rails.logger
    end

    # Save an event to the database
    #
    # @param event [Domain::Event] The event to save
    # @return [Domain::Event] The saved event
    def save_event(event)
      ActiveRecord::Base.transaction do
        # Ensure we have a valid UUID for aggregate_id
        # The source might not be in UUID format, so we'll use a valid UUID
        # based on the source string if necessary
        aggregate_id = valid_uuid?(event.source) ? event.source : generate_uuid_from_string(event.source)

        # Create a record in the database
        record = DomainEvent.new(
          aggregate_id: aggregate_id,
          event_type: event.name,
          payload: event.data
          # position is auto-generated by DB sequence
          # created_at will be set automatically
          # IMPORTANT: Never set record.id manually, always let the database auto-generate it
        )

        record.save!

        # Always create a new domain event with the database-generated ID using the factory
        new_event = Domain::EventFactory.create(
          id: record.id.to_s,
          name: event.name,
          source: event.source,
          data: event.data,
          timestamp: record.created_at
        )

        # Cache the event
        @events_cache[new_event.id] = new_event

        @logger_port.debug { "Event persisted to database: #{new_event.id}, position: #{record.position}" }
        new_event
      end
    rescue ActiveRecord::RecordInvalid => e
      @logger_port.error("Failed to save event: #{e.message}")
      raise "Failed to save event: #{e.message}"
    end

    # Find an event by ID
    #
    # @param id [String, Integer, Hash] The ID of the event to find
    # @return [Domain::Event, nil] The event if found, nil otherwise
    def find_event(id)
      # Handle the case where a hash is passed
      id = id["id"] if id.is_a?(Hash) && id.key?("id")

      # Always convert to string for cache lookup
      id_str = id.to_s

      # Try to fetch from cache first
      return @events_cache[id_str] if @events_cache.key?(id_str)

      # Check if this is a UUID - if so, find by aggregate_id
      if valid_uuid?(id_str)
        @logger_port.debug { "Looking up event by UUID: #{id_str}" }
        record = DomainEvent.find_by(aggregate_id: id_str)

        # If not found by aggregate_id, try one more approach
        unless record
          # Try to find all events and check if any has this UUID as a string ID
          # This is a fallback mechanism
          DomainEvent.all.each do |evt|
            if evt.id.to_s == id_str
              record = evt
              break
            end
          end
        end
      elsif id_str.match?(/^\d+$/)
        # If it's a numeric string, try to find by database ID
        @logger_port.debug { "Looking up event by numeric ID: #{id_str}" }
        record = DomainEvent.find_by(id: id_str.to_i)
      else
        # Otherwise, try both approaches
        @logger_port.debug { "Looking up event by ID (mixed strategy): #{id_str}" }
        record = DomainEvent.find_by(id: id_str)
        record ||= DomainEvent.find_by(aggregate_id: id_str)
      end

      return nil unless record

      # Convert to domain event using the factory and cache
      domain_event = Domain::EventFactory.from_record(record)
      @events_cache[domain_event.id] = domain_event
      @logger_port.debug { "Found event: #{domain_event.id} (#{domain_event.name})" }
      domain_event
    end

    # Event store specific operations
    def append_event(aggregate_id:, event_type:, payload:)
      ActiveRecord::Base.transaction do
        # Ensure we have a valid UUID for aggregate_id
        valid_aggregate_id = valid_uuid?(aggregate_id) ? aggregate_id : generate_uuid_from_string(aggregate_id)

        # Create a record in the database
        record = DomainEvent.create!(
          aggregate_id: valid_aggregate_id,
          event_type: event_type,
          payload: payload
          # position is auto-generated by DB sequence
          # created_at will be set automatically
        )

        # Convert to domain event using the factory
        domain_event = Domain::EventFactory.from_record(record)

        # Cache the event
        @events_cache[domain_event.id] = domain_event

        domain_event
      end
    end

    def read_events(from_position: 0, limit: nil)
      # Query the database
      query = DomainEvent.since_position(from_position).chronological
      query = query.limit(limit) if limit

      # Convert to domain events and cache them
      query.map do |record|
        # Check cache first
        event_id = record.id.to_s
        @events_cache[event_id] ||= Domain::EventFactory.from_record(record)
      end
    end

    def read_stream(aggregate_id:, from_position: 0, limit: nil)
      # Query the database for events of a specific aggregate
      valid_aggregate_id = valid_uuid?(aggregate_id) ? aggregate_id : generate_uuid_from_string(aggregate_id)

      query = DomainEvent.for_aggregate(valid_aggregate_id)
                         .since_position(from_position)
                         .chronological

      query = query.limit(limit) if limit

      # Convert to domain events and cache them
      query.map do |record|
        # Check cache first
        event_id = record.id.to_s
        @events_cache[event_id] ||= Domain::EventFactory.from_record(record)
      end
    end

    private

    # Check if a string is a valid UUID
    def valid_uuid?(string)
      uuid_regex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i
      uuid_regex.match?(string.to_s)
    end

    # Generate a deterministic UUID from a string
    def generate_uuid_from_string(string)
      # Simply use a random UUID for now
      # In a production system, you might want to use a more deterministic approach
      # such as a namespace UUID (v5) if available
      SecureRandom.uuid
    end
  end
end
