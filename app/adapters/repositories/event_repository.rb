module Adapters
  module Repositories
    # Database implementation of event storage using DomainEvent model
    class EventRepository
      include Ports::StoragePort

      require "securerandom"

      def initialize
        # Use memory as a cache, not primary storage
        @events_cache = {}
        @metrics = {}
        @alerts = {}
      end

      # Save an event to the database
      #
      # @param event [Core::Domain::Event] The event to save
      # @return [Core::Domain::Event] The saved event
      def save_event(event)
        ActiveRecord::Base.transaction do
          # Ensure we have a valid UUID for aggregate_id
          # The source might not be in UUID format, so we'll use a valid UUID
          # based on the source string if necessary
          aggregate_id = valid_uuid?(event.source) ? event.source : generate_uuid_from_string(event.source)

          # Create a record in the database
          record = DomainEvent.new(
            aggregate_id: aggregate_id,
            event_type: event.name,
            payload: event.data
            # position is auto-generated by DB sequence
            # created_at will be set automatically
          )

          # If the event has an ID already, use it, otherwise let DB generate one
          record.id = event.id if event.id.present?

          record.save!

          # Update the domain event with any generated values from the DB
          if event.id != record.id.to_s
            event = Core::Domain::Event.new(
              id: record.id.to_s,
              name: event.name,
              source: event.source,
              data: event.data,
              timestamp: record.created_at
            )
          end

          # Cache the event
          @events_cache[event.id] = event

          Rails.logger.debug { "Event persisted to database: #{event.id}, position: #{record.position}" }
          event
        end
      rescue ActiveRecord::RecordInvalid => e
        Rails.logger.error("Failed to save event: #{e.message}")
        raise "Failed to save event: #{e.message}"
      end

      # Find an event by ID
      #
      # @param id [String] The ID of the event to find
      # @return [Core::Domain::Event, nil] The event if found, nil otherwise
      def find_event(id)
        # Try to fetch from cache first
        return @events_cache[id] if @events_cache.key?(id)

        # If not in cache, fetch from database
        record = DomainEvent.find_by(id: id)
        return nil unless record

        # Convert to domain event and cache
        domain_event = domain_event_from_record(record)
        @events_cache[id] = domain_event
        domain_event
      end

      # Event store specific operations
      def append_event(aggregate_id:, event_type:, payload:)
        ActiveRecord::Base.transaction do
          # Ensure we have a valid UUID for aggregate_id
          valid_aggregate_id = valid_uuid?(aggregate_id) ? aggregate_id : generate_uuid_from_string(aggregate_id)

          # Create a record in the database
          record = DomainEvent.create!(
            aggregate_id: valid_aggregate_id,
            event_type: event_type,
            payload: payload
            # position is auto-generated by DB sequence
            # created_at will be set automatically
          )

          # Convert to domain event
          domain_event = domain_event_from_record(record)

          # Cache the event
          @events_cache[domain_event.id] = domain_event

          domain_event
        end
      end

      def read_events(from_position: 0, limit: nil)
        # Query the database
        query = DomainEvent.since_position(from_position).chronological
        query = query.limit(limit) if limit

        # Convert to domain events and cache them
        query.map do |record|
          # Check cache first
          event_id = record.id.to_s
          @events_cache[event_id] ||= domain_event_from_record(record)
        end
      end

      def read_stream(aggregate_id:, from_position: 0, limit: nil)
        # Query the database for events of a specific aggregate
        valid_aggregate_id = valid_uuid?(aggregate_id) ? aggregate_id : generate_uuid_from_string(aggregate_id)

        query = DomainEvent.for_aggregate(valid_aggregate_id)
                           .since_position(from_position)
                           .chronological

        query = query.limit(limit) if limit

        # Convert to domain events and cache them
        query.map do |record|
          # Check cache first
          event_id = record.id.to_s
          @events_cache[event_id] ||= domain_event_from_record(record)
        end
      end

      # Metric operations
      delegate :save_metric, to: :metric_repository

      def find_metric(id)
        # In a real implementation, this would query the database
        # For our test, we'll just fetch from memory
        @metrics[id]
      end

      def list_metrics(filters = {})
        # In a real implementation, this would query the database with filters
        # For our test, we'll just return all metrics
        @metrics.values
      end

      # Alert operations
      delegate :save_alert, to: :alert_repository

      def find_alert(id)
        # In a real implementation, this would query the database
        # For our test, we'll just fetch from memory
        @alerts[id]
      end

      def list_alerts(filters = {})
        # In a real implementation, this would query the database with filters
        # For our test, we'll just return all alerts
        @alerts.values
      end

      private

      # Convert a DomainEvent record to a Core::Domain::Event
      def domain_event_from_record(record)
        Core::Domain::Event.new(
          id: record.id.to_s,
          name: record.event_type,
          source: record.aggregate_id,
          timestamp: record.created_at,
          data: record.payload
        )
      end

      # Check if a string is a valid UUID
      def valid_uuid?(string)
        uuid_regex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i
        uuid_regex.match?(string.to_s)
      end

      # Generate a deterministic UUID from a string
      def generate_uuid_from_string(string)
        # Simply use a random UUID for now
        # In a production system, you might want to use a more deterministic approach
        # such as a namespace UUID (v5) if available
        SecureRandom.uuid
      end

      def metric_repository
        @metric_repository ||= Adapters::Repositories::MetricRepository.new
      end

      def alert_repository
        @alert_repository ||= Adapters::Repositories::AlertRepository.new
      end
    end
  end
end
